lexical id_seq = 2148425000

lexical RubyObject = (lexical klass) {
	lexical singleton = klass
	// TODO: make the generator be shared among all instances
	// of the same class so they all start with appropriately
	// sized hashes.
	lexical ivars = $BasicHash($prime_gen)
	lexical id = nil

	lexical self = (&msg) -> return {
		local name
		local is_c9
		bytecode(msg) {
			message_name
			dup_top
			local_set "name"
			push "__c9_"
			message_new "match" 0 1
			channel_call
			pop
			is 5
			local_set "is_c9"
		}
		if (is_c9) {
			switch (name)
			case ("__c9_ivar_get__") {
				local ivar_name = bytecode(msg) {
					message_unpack 1 0 0
					swap
					pop
				}
				return <- ivars.get(ivar_name)
			} case ("__c9_ivar_set__") {
				local ivar_name
				local ivar_val
				bytecode(msg) {
					message_unpack 2 0 0
					local_set "ivar_name"
					local_set "ivar_val"
				}
				return <- ivars.set(ivar_name, ivar_val)
			} case ("__c9_object_id__") {
				if (id) {
					return <- id
				} else {
					return <- id = (id_seq += 2) // even numbers are for objects
				}
			} case ("__c9_class__") {
				return <- klass
			} case ("__c9_wrap__") {
				// re-identify self as being the wrapping object.
				bytecode(msg) {
					message_unpack 1 0 0
					lexical_set 1 "self"
				}
				return <- self
			} case ("__c9_singleton__") {
				if (singleton == klass) {
					return <- nil
				} else {
					return <- singleton
				}
			} case ("__c9_make_singleton__") {
				if (singleton == klass) {
					return <- (singleton = $RubyClass(self.to_s, klass))
				} else {
					return <- singleton
				}
			} case ("__c9_set_singleton__") {
				singleton = bytecode(msg) {
					message_unpack 1 0 0
					swap
					pop
				}
				return <- singleton
			} case ("__c9_instance_eval__") {
				bytecode(msg) {
					message_sys_unpack 1
					swap
					pop
					local_get "return"
					lexical_get 1 "self"
					message_new "call" 1 0
					channel_send
				}
			}
		}

		local minfo = singleton.__c9_lookup__(name)
		if (minfo) {
			// build a new message
			bytecode(minfo.at(0), return, msg, self, minfo.at(1)) {
				message_sys_prefix 2
				channel_send
			}
		} else if (minfo = singleton.__c9_lookup__("method_missing")) {
			local fwd_msg = bytecode(minfo.at(0), return, msg, self, minfo.at(1)) {
				message_sys_prefix 2
				message_forward "method_missing"
				channel_send
			}
		} else {
			$unwinder.no_message_handler(klass.__c9_name__, name)
		}
	}
}

$set_special_channel('RubyObject', RubyObject)