lexical id_seq = 2148425000
lexical method_missing_lookup_msg = bytecode() {
	push "method_missing"
	message_new "__c9_lookup__" 0 1
}

lexical RubyObject = (lexical klass, lexical ivars) {
	lexical singleton = klass
	// TODO: make the generator be shared among all instances
	// of the same class so they all start with appropriately
	// sized hashes.
	if (ivars == nil) {
		ivars = $BasicHash($prime_gen)
	}
	lexical id = nil

	lexical self = (&msg) -> return {
		local name
		local is_c9
		bytecode(msg) {
			message_name
			dup_top
			local_set "name"
			push "__c9_"
			message_new "match" 0 1
			channel_call
			pop
			is 5
			local_set "is_c9"
		}
		if (is_c9) {
			switch (name)
			case ("__c9_ivar_get__") {
				local ivar_name = bytecode(msg) {
					message_unpack 1 0 0
					swap
					pop
				}
				return <- ivars.get(ivar_name)
			} case ("__c9_ivar_set__") {
				local ivar_name
				local ivar_val
				bytecode(msg) {
					message_unpack 2 0 0
					local_set "ivar_name"
					local_set "ivar_val"
				}
				return <- ivars.set(ivar_name, ivar_val)
			} case ("__c9_object_id__") {
				if (id) {
					return <- id
				} else {
					return <- id = (id_seq += 2) // even numbers are for objects
				}
			} case ("__c9_class__") {
				return <- klass
			} case ("__c9_wrap__") {
				// re-identify self as being the wrapping object.
				bytecode(msg) {
					message_unpack 1 0 0
					lexical_set 0 "self"
				}
				return <- self
			} case ("__c9_singleton__") {
				if (singleton == klass) {
					return <- nil
				} else {
					return <- singleton
				}
			} case ("__c9_make_singleton__") {
				if (singleton == klass) {
					return <- (singleton = $RubyClass(self.to_s, klass))
				} else {
					return <- singleton
				}
			} case ("__c9_set_singleton__") {
				singleton = bytecode(msg) {
					message_unpack 1 0 0
					swap
					pop
				}
				return <- singleton
			} case ("__c9_instance_eval__") {
				bytecode(msg) {
					message_sys_unpack 1
					swap
					pop
					local_get "return"
					lexical_get 0 "self"
					message_new "call" 1 0
					channel_send
				}
			} case ("__c9_dup__") {
				return <- RubyObject(klass, ivars.dup)
			}
		}

		local lookup_msg = bytecode(name) {
			message_new "__c9_lookup__" 0 1
		}

		local meth = lookup_msg -> singleton : local lookup_cont
		if (meth) {
			// build a new message
			bytecode(meth, return, msg, self, lookup_cont) {
				message_sys_prefix 2
				channel_send
			}
		} else if (meth = method_missing_lookup_msg -> singleton : lookup_cont) {
			local fwd_msg = bytecode(meth, return, msg, self, lookup_cont) {
				message_sys_prefix 2
				message_forward "method_missing"
				channel_send
			}
		} else {
			$unwinder.no_message_handler(klass.__c9_name__, name)
		}
	}
}

$set_special_channel('RubyObject', RubyObject)